#!/usr/bin/env perl

use strict;
use warnings;

use Getopt::Long;
use List::Util qw(sum);
use File::Slurp;
use Iterator::FastaDb;
use Iterator::FastqDb;
use File::Basename;

my $usage=<<'ENDHERE';
NAME:
pacBioProcessReadsFor16S.pl

PURPOSE:
Generate relevant plots and table(s) of current PacBio assembly.
Preprocess pacbio CCS files to make them compatible with the RRNA
amplicon pipeline (RRNATagger).

INPUT:
--infile <string>       : sampleSheet generated by pacBioSampleSetup.pl
--bySample <int>        : Each CCS will be considered as a sample (Default).

OUTPUT:
--outdir <string>       : Fastq file representing a concatenation of all CCS
                          reads specified in --infile.

NOTES:

BUGS/LIMITATIONS:
 
AUTHOR/SUPPORT:
Julien Tremblay - julien.tremblay@mail.mcgill.ca

ENDHERE

## OPTIONS
my ($help, $infile, $bySample, $outdir);
my $verbose = 0;

GetOptions(
  'infile=s' 	    => \$infile,
  'outdir=s'      => \$outdir,
  'bySample'      => \$bySample,
  'verbose' 	    => \$verbose,
  'help' 		     	=> \$help
);
if ($help) { print $usage; exit; }

## Validate
die "--infile missing\n" unless($infile);
die "--outdir missing\n" unless($outdir);

## MAIN
#open(OUT, ">".$outfile) or die "Can't open $outfile\n";

# Unzip files
my %hash;
open(IN, "<".$infile) or die "Can't open $infile\n";
while(<IN>){
  chomp;
  my @row = split(/\t/, $_);
  my $sampleName = $row[0];
  my $well = $row[1];
  my $file = $row[2];
  
  system("unzip -o ".$file." -d ".$outdir."/");
  $file = basename($file);
  $file =~ s/\.zip//;
  $file = "$outdir/$file";

  #print STDERR "[DEBUG] ".$file."\n";
  $hash{$sampleName}{$well} = $file;
  print STDERR "[DEBUG] ".$hash{$sampleName}{$well}."\n";
}
close(IN);

my @mergedFastqs;
# Then merge uncompressed fastq files.
foreach my $sampleName (keys %hash){
  print STDERR "[DEBUG] ".$sampleName."\n";  

  my $cmd = "cat ";
  foreach my $well (keys %{ $hash{$sampleName} }){ 
    print STDERR "[DEBUG]\t ".$well."\n";  
    print STDERR "[DEBUG] ".$hash{$sampleName}{$well}."\n";
      
    $cmd .= $hash{$sampleName}{$well}." ";
  }
  $cmd .= "> $outdir/$sampleName.fastq";
  print STDERR "[DEBUG] ".$cmd."\n";
  system($cmd);
  push(@mergedFastqs, "$outdir/$sampleName.fastq");
}

# Generate dummy indexes
my @new_barcodes = getBarcodes();

# Then assign a fake barcode to each sample/merged fastq file.
open(BARCODES, ">".$outdir."/barcodes.fasta") or die "Can't open $outdir/barcodes.fasta\n";
open(INDEX, ">".$outdir."/index.tsv") or die "Can't open $outdir/index.tsv\n";

my @mergedFastqsWithBarcodes;
foreach my $fastq (@mergedFastqs){
  my $currBarcode = shift(@new_barcodes);
  
  print INDEX "$fastq\t$currBarcode\n";
  print BARCODES ">".$fastq."\n".$currBarcode."\n";
  print STDERR "[DEBUG] Processing ".$fastq."\n";
  print STDERR "[DEBUG] Processing ".$currBarcode."\n";
  
  my $outfile = $fastq;
  $outfile =~ s/\.fastq/_withBarcodes\.fastq/;
  open(OUT, ">".$outfile) or die "Can't open $outfile\n";

  my $ref_fastq_db = Iterator::FastqDb->new($fastq) or die("Unable to open Fasta file, $fastq\n");
  while( my $curr = $ref_fastq_db->next_seq() ) {
    print OUT $curr->header."#".$currBarcode."\n".$curr->seq."\n+\n".$curr->qual."\n"; 
  }
  close(OUT);
  push(@mergedFastqsWithBarcodes, $outfile);
}
close(BARCODES);
close(INDEX);

#open(FINAL, ">".$outdir."/combinedReads.fastq") or die "Can't open $outdir/combinedReads.fastq\n";
my $cmd = "cat ";
foreach(@mergedFastqsWithBarcodes){
  $cmd .= $_." ";
}
$cmd .= "> ".$outdir."/combinedReads.fastq";
system($cmd);

# Finally merge all fastqs with barcodes as one single fastq.

exit;

sub getBarcodes {
	my $i=0;
	my $j=0;
	my @barcodes;
	for(glob '{A,C,G,T}{A,C,G,T}{A,C,G,T}{A,C,G,T}{A,C,G,T}{A,C,G,T}{A,C,G,T}{A,C,G,T}{A,C,G,T}'){
	    if($i % 30 == 0){
			$barcodes[$j] = $_;
			$j++;
		}else{
		
		}
		$i++;
	}
	
	## CHECK IF EACH BARCODES ARE UNIQUE.
	my %hash = ();
	foreach(@barcodes){
		$hash{$_} = 1;
	}
	
	#foreach(@barcodes){
	my %hash_check = ();
	while ( my ($key, $value) = each(%hash) ) {
		if(exists $hash_check{$key}){
			$hash_check{$key}++;
			die("Barcodes is in duplicate: ".$key."\n");
		}else{
			$hash_check{$key} = 1;
		}
	}
	
	my @barcodes_nodup;
	while ( my ($key, $value) = each(%hash_check) ) {
		if($value <= 1){
			#print "$key => $value\n" 
			push(@barcodes_nodup, $key);
		}
	}
	
	return @barcodes_nodup;	
	#exit;
}



exit;
